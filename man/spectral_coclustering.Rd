% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/biclustering.R
\name{spectral_coclustering}
\alias{spectral_coclustering}
\title{Spectral co-clustering}
\usage{
spectral_coclustering(
  X,
  n_clusters,
  clust_seed = NULL,
  arpack = TRUE,
  kmeanspp = TRUE,
  ...
)
}
\arguments{
\item{X}{a numeric matrix or a data frame of numeric values. In the case of negative values the data is scaled.}

\item{n_clusters}{positive integer >= 2. The amount of clusters to use.}

\item{clust_seed}{NULL or a single value, optional seed number designation for reproducible results.}

\item{arpack}{boolean specifying whether arpack-method is used for single value decomposition. By default,
SVD is conducted using irlba::svdr() function which uses the robust arpack method (recommended). The alternative uses the base::svd() function which might be faster with large matrices.}

\item{kmeanspp}{boolean specifying whether to use kmeans++ for initialization (recommended). By default the clustering is conducted using maotai::kmeanspp(), which produces more accurate results (recommended).
If faster run times are desired, the alternative uses stats::kmeans().}

\item{...}{other arguments are passed on to stats::kmeans.}
}
\value{
Returns a list with entries:
row_vec: a vector of cluster assignments for the rows
col_vec: a vector of cluster assignments for the columns
n_cluster: integer, the number of clusters
}
\description{
Runs spectral co-clustering (biclustering) on matrix X.
}
\details{
Biclustering algorithms simultaneously cluster rows and columns of a data matrix.
These clusters of rows and columns are known as biclusters, which each determine a submatrix of the original data matrix with some desired properties.
For instance, given a matrix of shape (10, 10), one possible bicluster with three rows and two columns induces a submatrix of shape (3, 2).

The spectral coclustering algorithm models a data matrix as a bipartite graph between columns and rows,
where simultaneous clustering problem can be posed as a bipartite graph partitioning problem.
This is solved using an appropriate scaling of the data matrix followed by singular value decomposition.
The resulting graph yields a checkerboard structure, where each row and columns belong exactly one bicluster.
}
\examples{
{#generate data and visualize it
data <- generate_example_matrix()
heatmap(data$original, Rowv = NA, Colv = NA)

#run coclustering on the randomized data and visualize the reordered data
bc <- spectral_coclustering(data$randomized, n_clusters = 4, arpack = TRUE)
r.ind <- sort.int(bc$row_vec,index.return = TRUE)$ix
c.ind <- sort.int(bc$col_vec,index.return = TRUE)$ix
heatmap(
  data$randomized[r.ind,c.ind], Rowv = NA, Colv = NA)
}

}
\references{
https://doi.org/10.1145/502512.502550
}
